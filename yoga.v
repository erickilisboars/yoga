module yoga

#flag -I @VMODROOT/include
#flag @VMODROOT/lib/libyogacore.a
#flag -lstdc++
#flag -lm
#include "yoga/Yoga.h"

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
// @generated by enums.py
// clang-format off
pub enum Align {
	align_auto
	align_flex_start
	align_center
	align_flex_end
	align_stretch
	align_baseline
	align_space_between
	align_space_around
	align_space_evenly
}

fn C.YGAlignToString(arg0 YGAlign) &i8

pub fn align_to_string(arg0 YGAlign) &i8 {
	return C.YGAlignToString(arg0)
}

enum BoxSizing {
	box_sizing_border_box
	box_sizing_content_box
}

fn C.YGBoxSizingToString(arg0 YGBoxSizing) &i8

pub fn box_sizing_to_string(arg0 YGBoxSizing) &i8 {
	return C.YGBoxSizingToString(arg0)
}

enum Dimension {
	dimension_width
	dimension_height
}

fn C.YGDimensionToString(arg0 YGDimension) &i8

pub fn dimension_to_string(arg0 YGDimension) &i8 {
	return C.YGDimensionToString(arg0)
}

pub enum Direction {
	direction_inherit
	direction_ltr
	direction_rtl
}

fn C.YGDirectionToString(arg0 YGDirection) &i8

pub fn direction_to_string(arg0 YGDirection) &i8 {
	return C.YGDirectionToString(arg0)
}

enum Display {
	display_flex
	display_none
	display_contents
}

fn C.YGDisplayToString(arg0 YGDisplay) &i8

pub fn display_to_string(arg0 YGDisplay) &i8 {
	return C.YGDisplayToString(arg0)
}

pub enum Edge {
	edge_left
	edge_top
	edge_right
	edge_bottom
	edge_start
	edge_end
	edge_horizontal
	edge_vertical
	edge_all
}

fn C.YGEdgeToString(arg0 YGEdge) &i8

pub fn edge_to_string(arg0 YGEdge) &i8 {
	return C.YGEdgeToString(arg0)
}

enum Errata {
	errata_none = 0
	errata_stretch_flex_basis = 1
	errata_absolute_position_without_insets_excludes_padding = 2
	errata_absolute_percent_against_inner_size = 4
	errata_all = 2147483647
	errata_classic = 2147483646
}

fn C.YGErrataToString(arg0 YGErrata) &i8

pub fn errata_to_string(arg0 YGErrata) &i8 {
	return C.YGErrataToString(arg0)
}

enum ExperimentalFeature {
	experimental_feature_web_flex_basis
}

fn C.YGExperimentalFeatureToString(arg0 YGExperimentalFeature) &i8

pub fn experimental_feature_to_string(arg0 YGExperimentalFeature) &i8 {
	return C.YGExperimentalFeatureToString(arg0)
}

pub enum FlexDirection {
	flex_direction_column
	flex_direction_column_reverse
	flex_direction_row
	flex_direction_row_reverse
}

fn C.YGFlexDirectionToString(arg0 YGFlexDirection) &i8

pub fn flex_direction_to_string(arg0 YGFlexDirection) &i8 {
	return C.YGFlexDirectionToString(arg0)
}

enum Gutter {
	gutter_column
	gutter_row
	gutter_all
}

fn C.YGGutterToString(arg0 YGGutter) &i8

pub fn gutter_to_string(arg0 YGGutter) &i8 {
	return C.YGGutterToString(arg0)
}

enum Justify {
	justify_flex_start
	justify_center
	justify_flex_end
	justify_space_between
	justify_space_around
	justify_space_evenly
}

fn C.YGJustifyToString(arg0 YGJustify) &i8

pub fn justify_to_string(arg0 YGJustify) &i8 {
	return C.YGJustifyToString(arg0)
}

enum LogLevel {
	log_level_error
	log_level_warn
	log_level_info
	log_level_debug
	log_level_verbose
	log_level_fatal
}

fn C.YGLogLevelToString(arg0 YGLogLevel) &i8

pub fn log_level_to_string(arg0 YGLogLevel) &i8 {
	return C.YGLogLevelToString(arg0)
}

enum MeasureMode {
	measure_mode_undefined
	measure_mode_exactly
	measure_mode_at_most
}

fn C.YGMeasureModeToString(arg0 YGMeasureMode) &i8

pub fn measure_mode_to_string(arg0 YGMeasureMode) &i8 {
	return C.YGMeasureModeToString(arg0)
}

enum NodeType {
	node_type_default
	node_type_text
}

fn C.YGNodeTypeToString(arg0 YGNodeType) &i8

pub fn node_type_to_string(arg0 YGNodeType) &i8 {
	return C.YGNodeTypeToString(arg0)
}

enum Overflow {
	overflow_visible
	overflow_hidden
	overflow_scroll
}

fn C.YGOverflowToString(arg0 YGOverflow) &i8

pub fn overflow_to_string(arg0 YGOverflow) &i8 {
	return C.YGOverflowToString(arg0)
}

enum PositionType {
	position_type_static
	position_type_relative
	position_type_absolute
}

fn C.YGPositionTypeToString(arg0 YGPositionType) &i8

pub fn position_type_to_string(arg0 YGPositionType) &i8 {
	return C.YGPositionTypeToString(arg0)
}

enum Unit {
	unit_undefined
	unit_point
	unit_percent
	unit_auto
	unit_max_content
	unit_fit_content
	unit_stretch
}

fn C.YGUnitToString(arg0 YGUnit) &i8

pub fn unit_to_string(arg0 YGUnit) &i8 {
	return C.YGUnitToString(arg0)
}

enum Wrap {
	wrap_no_wrap
	wrap_wrap
	wrap_wrap_reverse
}

fn C.YGWrapToString(arg0 YGWrap) &i8

pub fn wrap_to_string(arg0 YGWrap) &i8 {
	return C.YGWrapToString(arg0)
}

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
pub type NodeRef = voidptr
pub type ConfigRef = voidptr
pub type YGNodeRef = voidptr
pub type YGConfigRef = voidptr

pub struct YGNode {}
pub struct YGConfig {}

pub type YGNodeConstRef = &YGNode
pub type YGConfigConstRef = &YGConfig

pub type YGAlign = Align
pub type YGBoxSizing = BoxSizing
pub type YGDimension = Dimension
pub type YGDirection = Direction
pub type YGDisplay = Display
pub type YGEdge = Edge
pub type YGErrata = Errata
pub type YGExperimentalFeature = ExperimentalFeature
pub type YGFlexDirection = FlexDirection
pub type YGGutter = Gutter
pub type YGJustify = Justify
pub type YGLogLevel = LogLevel
pub type YGMeasureMode = MeasureMode
pub type YGNodeType = NodeType
pub type YGOverflow = Overflow
pub type YGPositionType = PositionType
pub type YGUnit = Unit
pub type YGWrap = Wrap
//* *Allocates a set of configuration options. The configuration may be applied to
// *multiple nodes (i.e. a single global config), or can be applied more
// *granularly per-node.
// 
fn C.YGConfigNew() YGConfigRef

pub fn config_new() YGConfigRef {
	return C.YGConfigNew()
}

//* *Frees the associated Yoga configuration.
// 
fn C.YGConfigFree(config YGConfigRef)

pub fn config_free(config YGConfigRef) {
	C.YGConfigFree(config)
}

//* *Returns the default config values set by Yoga.
// 
fn C.YGConfigGetDefault() YGConfigConstRef

pub fn config_get_default() YGConfigConstRef {
	return C.YGConfigGetDefault()
}

//* *Yoga by default creates new nodes with style defaults different from flexbox
// *on web (e.g. `YGFlexDirectionColumn` and `YGPositionRelative`).
// *`UseWebDefaults` instructs Yoga to instead use a default style consistent
// *with the web.
// 
fn C.YGConfigSetUseWebDefaults(config YGConfigRef, enabled bool)

pub fn config_set_use_web_defaults(config YGConfigRef, enabled bool) {
	C.YGConfigSetUseWebDefaults(config, enabled)
}

//* *Whether the configuration is set to use web defaults.
// 
fn C.YGConfigGetUseWebDefaults(config YGConfigConstRef) bool

pub fn config_get_use_web_defaults(config YGConfigConstRef) bool {
	return C.YGConfigGetUseWebDefaults(config)
}

//* *Yoga will by default round final layout positions and dimensions to the
// *nearst point. `pointScaleFactor` controls the density of the grid used for
// *layout rounding (e.g. to round to the closest display pixel).
// * *May be set to 0.0f to avoid rounding the layout results.
// 
fn C.YGConfigSetPointScaleFactor(config YGConfigRef, pixels_in_point f32)

pub fn config_set_point_scale_factor(config YGConfigRef, pixels_in_point f32) {
	C.YGConfigSetPointScaleFactor(config, pixels_in_point)
}

//* *Get the currently set point scale factor.
// 
fn C.YGConfigGetPointScaleFactor(config YGConfigConstRef) f32

pub fn config_get_point_scale_factor(config YGConfigConstRef) f32 {
	return C.YGConfigGetPointScaleFactor(config)
}

//* *Configures how Yoga balances W3C conformance vs compatibility with layouts
// *created against earlier versions of Yoga.
// * *By default Yoga will prioritize W3C conformance. `Errata` may be set to ask
// *Yoga to produce specific incorrect behaviors. E.g. `YGConfigSetErrata(config,
// *YGErrataStretchFlexBasis)`.
// * *YGErrata is a bitmask, and multiple errata may be set at once. Predefined
// *constants exist for convenience:
// *1. YGErrataNone: No errata
// *2. YGErrataClassic: Match layout behaviors of Yoga 1.x
// *3. YGErrataAll: Match layout behaviors of Yoga 1.x, including
// *`UseLegacyStretchBehaviour`
// 
fn C.YGConfigSetErrata(config YGConfigRef, errata YGErrata)

pub fn config_set_errata(config YGConfigRef, errata YGErrata) {
	C.YGConfigSetErrata(config, errata)
}

//* *Get the currently set errata.
// 
fn C.YGConfigGetErrata(config YGConfigConstRef) YGErrata

pub fn config_get_errata(config YGConfigConstRef) YGErrata {
	return C.YGConfigGetErrata(config)
}

//* *Function pointer type for YGConfigSetLogger.
// 
type YGLogger = voidptr
//* *Set a custom log function for to use when logging diagnostics or fatal.
// *errors.
// 
fn C.YGConfigSetLogger(config YGConfigRef, logger YGLogger)

pub fn config_set_logger(config YGConfigRef, logger YGLogger) {
	C.YGConfigSetLogger(config, logger)
}

//* *Sets an arbitrary context pointer on the config which may be read from during
// *callbacks.
// 
fn C.YGConfigSetContext(config YGConfigRef, context voidptr)

pub fn config_set_context(config YGConfigRef, context voidptr) {
	C.YGConfigSetContext(config, context)
}

//* *Gets the currently set context.
// 
fn C.YGConfigGetContext(config YGConfigConstRef) voidptr

pub fn config_get_context(config YGConfigConstRef) voidptr {
	return C.YGConfigGetContext(config)
}

//* *Function pointer type for YGConfigSetCloneNodeFunc.
// 
type YGCloneNodeFunc = fn (YGNodeConstRef, YGNodeConstRef, usize) YGNodeRef
//* *Enable an experimental/unsupported feature in Yoga.
// 
fn C.YGConfigSetExperimentalFeatureEnabled(config YGConfigRef, feature YGExperimentalFeature, enabled bool)

pub fn config_set_experimental_feature_enabled(config YGConfigRef, feature YGExperimentalFeature, enabled bool) {
	C.YGConfigSetExperimentalFeatureEnabled(config, feature, enabled)
}

//* *Whether an experimental feature is set.
// 
fn C.YGConfigIsExperimentalFeatureEnabled(config YGConfigConstRef, feature YGExperimentalFeature) bool

pub fn config_is_experimental_feature_enabled(config YGConfigConstRef, feature YGExperimentalFeature) bool {
	return C.YGConfigIsExperimentalFeatureEnabled(config, feature)
}

//* *Sets a callback, called during layout, to create a new mutable Yoga node if
// *Yoga must write to it and its owner is not its parent observed during layout.
// 
fn C.YGConfigSetCloneNodeFunc(config YGConfigRef, callback YGCloneNodeFunc)

pub fn config_set_clone_node_func(config YGConfigRef, callback YGCloneNodeFunc) {
	C.YGConfigSetCloneNodeFunc(config, callback)
}

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
//* *Handle to a mutable Yoga Node.
// 
//* *Handle to an immutable Yoga Node.
// 
//* *Heap allocates and returns a new Yoga node using Yoga settings.
// 
fn C.YGNodeNew() YGNodeRef

pub fn node_new() YGNodeRef {
	return C.YGNodeNew()
}

//* *Heap allocates and returns a new Yoga node, with customized settings.
// 
fn C.YGNodeNewWithConfig(config YGConfigConstRef) YGNodeRef

pub fn node_new_with_config(config YGConfigConstRef) YGNodeRef {
	return C.YGNodeNewWithConfig(config)
}

//* *Returns a mutable copy of an existing node, with the same context and
// *children, but no owner set. Does not call the function set by
// *YGConfigSetCloneNodeFunc().
// 
fn C.YGNodeClone(node YGNodeConstRef) YGNodeRef

pub fn node_clone(node YGNodeConstRef) YGNodeRef {
	return C.YGNodeClone(node)
}

//* *Frees the Yoga node, disconnecting it from its owner and children.
// 
fn C.YGNodeFree(node YGNodeRef)

pub fn node_free(node YGNodeRef) {
	C.YGNodeFree(node)
}

//* *Frees the subtree of Yoga nodes rooted at the given node.
// 
fn C.YGNodeFreeRecursive(node YGNodeRef)

pub fn node_free_recursive(node YGNodeRef) {
	C.YGNodeFreeRecursive(node)
}

//* *Frees the Yoga node without disconnecting it from its owner or children.
// *Allows garbage collecting Yoga nodes in parallel when the entire tree is
// *unreachable.
// 
fn C.YGNodeFinalize(node YGNodeRef)

pub fn node_finalize(node YGNodeRef) {
	C.YGNodeFinalize(node)
}

//* *Resets the node to its default state.
// 
fn C.YGNodeReset(node YGNodeRef)

pub fn node_reset(node YGNodeRef) {
	C.YGNodeReset(node)
}

//* *Calculates the layout of the tree rooted at the given node.
// * *Layout results may be read after calling YGNodeCalculateLayout() using
// *functions like YGNodeLayoutGetLeft(), YGNodeLayoutGetTop(), etc.
// * *YGNodeGetHasNewLayout() may be read to know if the layout of the node or its
// *subtrees may have changed since the last time YGNodeCalculate() was called.
// 
fn C.YGNodeCalculateLayout(node YGNodeRef, available_width f32, available_height f32, owner_direction YGDirection)

pub fn node_calculate_layout(node YGNodeRef, available_width f32, available_height f32, owner_direction YGDirection) {
	C.YGNodeCalculateLayout(node, available_width, available_height, owner_direction)
}

//* *Whether the given node may have new layout results. Must be reset by calling
// *YGNodeSetHasNewLayout().
// 
fn C.YGNodeGetHasNewLayout(node YGNodeConstRef) bool

pub fn node_get_has_new_layout(node YGNodeConstRef) bool {
	return C.YGNodeGetHasNewLayout(node)
}

//* *Sets whether a nodes layout is considered new.
// 
fn C.YGNodeSetHasNewLayout(node YGNodeRef, has_new_layout bool)

pub fn node_set_has_new_layout(node YGNodeRef, has_new_layout bool) {
	C.YGNodeSetHasNewLayout(node, has_new_layout)
}

//* *Whether the node's layout results are dirty due to it or its children
// *changing.
// 
fn C.YGNodeIsDirty(node YGNodeConstRef) bool

pub fn node_is_dirty(node YGNodeConstRef) bool {
	return C.YGNodeIsDirty(node)
}

//* *Marks a node with custom measure function as dirty.
// 
fn C.YGNodeMarkDirty(node YGNodeRef)

pub fn node_mark_dirty(node YGNodeRef) {
	C.YGNodeMarkDirty(node)
}

type YGDirtiedFunc = fn (YGNodeConstRef)
//* *Called when a change is made to the Yoga tree which dirties this node.
// 
fn C.YGNodeSetDirtiedFunc(node YGNodeRef, dirtied_func YGDirtiedFunc)

pub fn node_set_dirtied_func(node YGNodeRef, dirtied_func YGDirtiedFunc) {
	C.YGNodeSetDirtiedFunc(node, dirtied_func)
}

//* *Returns a dirtied func if set.
// 
fn C.YGNodeGetDirtiedFunc(node YGNodeConstRef) YGDirtiedFunc

pub fn node_get_dirtied_func(node YGNodeConstRef) YGDirtiedFunc {
	return C.YGNodeGetDirtiedFunc(node)
}

//* *Inserts a child node at the given index.
// 
fn C.YGNodeInsertChild(node YGNodeRef, child YGNodeRef, index usize)

pub fn node_insert_child(node YGNodeRef, child YGNodeRef, index usize) {
	C.YGNodeInsertChild(node, child, index)
}

//* *Replaces the child node at a given index with a new one.
// 
fn C.YGNodeSwapChild(node YGNodeRef, child YGNodeRef, index usize)

pub fn node_swap_child(node YGNodeRef, child YGNodeRef, index usize) {
	C.YGNodeSwapChild(node, child, index)
}

//* *Removes the given child node.
// 
fn C.YGNodeRemoveChild(node YGNodeRef, child YGNodeRef)

pub fn node_remove_child(node YGNodeRef, child YGNodeRef) {
	C.YGNodeRemoveChild(node, child)
}

//* *Removes all children nodes.
// 
fn C.YGNodeRemoveAllChildren(node YGNodeRef)

pub fn node_remove_all_children(node YGNodeRef) {
	C.YGNodeRemoveAllChildren(node)
}

//* *Sets children according to the given list of nodes.
// 
fn C.YGNodeSetChildren(owner YGNodeRef, children &YGNodeRef, count usize)

pub fn node_set_children(owner YGNodeRef, children &YGNodeRef, count usize) {
	C.YGNodeSetChildren(owner, children, count)
}

//* *Get the child node at a given index.
// 
fn C.YGNodeGetChild(node YGNodeRef, index usize) YGNodeRef

pub fn node_get_child(node YGNodeRef, index usize) YGNodeRef {
	return C.YGNodeGetChild(node, index)
}

//* *The number of child nodes.
// 
fn C.YGNodeGetChildCount(node YGNodeConstRef) usize

pub fn node_get_child_count(node YGNodeConstRef) usize {
	return C.YGNodeGetChildCount(node)
}

//* *Get the parent/owner currently set for a node.
// 
fn C.YGNodeGetOwner(node YGNodeRef) YGNodeRef

pub fn node_get_owner(node YGNodeRef) YGNodeRef {
	return C.YGNodeGetOwner(node)
}

//* *Get the parent/owner currently set for a node.
// 
fn C.YGNodeGetParent(node YGNodeRef) YGNodeRef

pub fn node_get_parent(node YGNodeRef) YGNodeRef {
	return C.YGNodeGetParent(node)
}

//* *Set a new config for the node after creation.
// 
fn C.YGNodeSetConfig(node YGNodeRef, config YGConfigRef)

pub fn node_set_config(node YGNodeRef, config YGConfigRef) {
	C.YGNodeSetConfig(node, config)
}

//* *Get the config currently set on the node.
// 
fn C.YGNodeGetConfig(node YGNodeRef) YGConfigConstRef

pub fn node_get_config(node YGNodeRef) YGConfigConstRef {
	return C.YGNodeGetConfig(node)
}

//* *Sets extra data on the Yoga node which may be read from during callbacks.
// 
fn C.YGNodeSetContext(node YGNodeRef, context voidptr)

pub fn node_set_context(node YGNodeRef, context voidptr) {
	C.YGNodeSetContext(node, context)
}

//* *Returns the context or NULL if no context has been set.
// 
fn C.YGNodeGetContext(node YGNodeConstRef) voidptr

pub fn node_get_context(node YGNodeConstRef) voidptr {
	return C.YGNodeGetContext(node)
}

struct Size { 
	width f32
	height f32
}
//* *Returns the computed dimensions of the node, following the constraints of
// *`widthMode` and `heightMode`:
// * *YGMeasureModeUndefined: The parent has not imposed any constraint on the
// *child. It can be whatever size it wants.
// * *YGMeasureModeAtMost: The child can be as large as it wants up to the
// *specified size.
// * *YGMeasureModeExactly: The parent has determined an exact size for the
// *child. The child is going to be given those bounds regardless of how big it
// *wants to be.
// * *@returns the size of the leaf node, measured under the given constraints.
// 
type YGSize = Size
type YGValue = Value
type YGMeasureFunc = fn (YGNodeConstRef, f32, YGMeasureMode, f32, YGMeasureMode) YGSize
//* *Allows providing custom measurements for a Yoga leaf node (usually for
// *measuring text). YGNodeMarkDirty() must be set if content effecting the
// *measurements of the node changes.
// 
fn C.YGNodeSetMeasureFunc(node YGNodeRef, measure_func YGMeasureFunc)

pub fn node_set_measure_func(node YGNodeRef, measure_func YGMeasureFunc) {
	C.YGNodeSetMeasureFunc(node, measure_func)
}

//* *Whether a measure function is set.
// 
fn C.YGNodeHasMeasureFunc(node YGNodeConstRef) bool

pub fn node_has_measure_func(node YGNodeConstRef) bool {
	return C.YGNodeHasMeasureFunc(node)
}

//* *@returns a defined offset to baseline (ascent).
// 
type YGBaselineFunc = fn (YGNodeConstRef, f32, f32) f32
//* *Set a custom function for determining the text baseline for use in baseline
// *alignment.
// 
fn C.YGNodeSetBaselineFunc(node YGNodeRef, baseline_func YGBaselineFunc)

pub fn node_set_baseline_func(node YGNodeRef, baseline_func YGBaselineFunc) {
	C.YGNodeSetBaselineFunc(node, baseline_func)
}

//* *Whether a baseline function is set.
// 
fn C.YGNodeHasBaselineFunc(node YGNodeConstRef) bool

pub fn node_has_baseline_func(node YGNodeConstRef) bool {
	return C.YGNodeHasBaselineFunc(node)
}

//* *Sets this node should be considered the reference baseline among siblings.
// 
fn C.YGNodeSetIsReferenceBaseline(node YGNodeRef, is_reference_baseline bool)

pub fn node_set_is_reference_baseline(node YGNodeRef, is_reference_baseline bool) {
	C.YGNodeSetIsReferenceBaseline(node, is_reference_baseline)
}

//* *Whether this node is set as the reference baseline.
// 
fn C.YGNodeIsReferenceBaseline(node YGNodeConstRef) bool

pub fn node_is_reference_baseline(node YGNodeConstRef) bool {
	return C.YGNodeIsReferenceBaseline(node)
}

//* *Sets whether a leaf node's layout results may be truncated during layout
// *rounding.
// 
fn C.YGNodeSetNodeType(node YGNodeRef, node_type YGNodeType)

pub fn node_set_node_type(node YGNodeRef, node_type YGNodeType) {
	C.YGNodeSetNodeType(node, node_type)
}

//* *Wwhether a leaf node's layout results may be truncated during layout
// *rounding.
// 
fn C.YGNodeGetNodeType(node YGNodeConstRef) YGNodeType

pub fn node_get_node_type(node YGNodeConstRef) YGNodeType {
	return C.YGNodeGetNodeType(node)
}

//* *Make it so that this node will always form a containing block for any
// *descendant nodes. This is useful for when a node has a property outside of
// *of Yoga that will form a containing block. For example, transforms or some of
// *the others listed in
// *https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block
// 
fn C.YGNodeSetAlwaysFormsContainingBlock(node YGNodeRef, always_forms_containing_block bool)

pub fn node_set_always_forms_containing_block(node YGNodeRef, always_forms_containing_block bool) {
	C.YGNodeSetAlwaysFormsContainingBlock(node, always_forms_containing_block)
}

//* *Whether the node will always form a containing block for any descendant. This
// *can happen in situation where the client implements something like a
// *transform that can affect containing blocks but is not handled by Yoga
// *directly.
// 
fn C.YGNodeGetAlwaysFormsContainingBlock(node YGNodeConstRef) bool

pub fn node_get_always_forms_containing_block(node YGNodeConstRef) bool {
	return C.YGNodeGetAlwaysFormsContainingBlock(node)
}

//* *@deprecated
// 
fn C.YGNodeCanUseCachedMeasurement(width_mode YGMeasureMode, available_width f32, height_mode YGMeasureMode, available_height f32, last_width_mode YGMeasureMode, last_available_width f32, last_height_mode YGMeasureMode, last_available_height f32, last_computed_width f32, last_computed_height f32, margin_row f32, margin_column f32, config YGConfigRef) bool

pub fn node_can_use_cached_measurement(width_mode YGMeasureMode, available_width f32, height_mode YGMeasureMode, available_height f32, last_width_mode YGMeasureMode, last_available_width f32, last_height_mode YGMeasureMode, last_available_height f32, last_computed_width f32, last_computed_height f32, margin_row f32, margin_column f32, config YGConfigRef) bool {
	return C.YGNodeCanUseCachedMeasurement(width_mode, available_width, height_mode, available_height, last_width_mode, last_available_width, last_height_mode, last_available_height, last_computed_width, last_computed_height, margin_row, margin_column, config)
}

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
fn C.YGNodeLayoutGetLeft(node YGNodeConstRef) f32

pub fn node_layout_get_left(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetLeft(node)
}

fn C.YGNodeLayoutGetTop(node YGNodeConstRef) f32

pub fn node_layout_get_top(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetTop(node)
}

fn C.YGNodeLayoutGetRight(node YGNodeConstRef) f32

pub fn node_layout_get_right(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetRight(node)
}

fn C.YGNodeLayoutGetBottom(node YGNodeConstRef) f32

pub fn node_layout_get_bottom(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetBottom(node)
}

fn C.YGNodeLayoutGetWidth(node YGNodeConstRef) f32

pub fn node_layout_get_width(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetWidth(node)
}

fn C.YGNodeLayoutGetHeight(node YGNodeConstRef) f32

pub fn node_layout_get_height(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetHeight(node)
}

fn C.YGNodeLayoutGetDirection(node YGNodeConstRef) YGDirection

pub fn node_layout_get_direction(node YGNodeConstRef) YGDirection {
	return C.YGNodeLayoutGetDirection(node)
}

fn C.YGNodeLayoutGetHadOverflow(node YGNodeConstRef) bool

pub fn node_layout_get_had_overflow(node YGNodeConstRef) bool {
	return C.YGNodeLayoutGetHadOverflow(node)
}

// Get the computed values for these nodes after performing layout. If they were
// set using point values then the returned value will be the same as
// YGNodeStyleGetXXX. However if they were set using a percentage value then the
// returned value is the computed value used during layout.
fn C.YGNodeLayoutGetMargin(node YGNodeConstRef, edge YGEdge) f32

pub fn node_layout_get_margin(node YGNodeConstRef, edge YGEdge) f32 {
	return C.YGNodeLayoutGetMargin(node, edge)
}

fn C.YGNodeLayoutGetBorder(node YGNodeConstRef, edge YGEdge) f32

pub fn node_layout_get_border(node YGNodeConstRef, edge YGEdge) f32 {
	return C.YGNodeLayoutGetBorder(node, edge)
}

fn C.YGNodeLayoutGetPadding(node YGNodeConstRef, edge YGEdge) f32

pub fn node_layout_get_padding(node YGNodeConstRef, edge YGEdge) f32 {
	return C.YGNodeLayoutGetPadding(node, edge)
}

//* *Return the measured height of the node, before layout rounding
// 
fn C.YGNodeLayoutGetRawHeight(node YGNodeConstRef) f32

pub fn node_layout_get_raw_height(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetRawHeight(node)
}

//* *Return the measured width of the node, before layout rounding
// 
fn C.YGNodeLayoutGetRawWidth(node YGNodeConstRef) f32

pub fn node_layout_get_raw_width(node YGNodeConstRef) f32 {
	return C.YGNodeLayoutGetRawWidth(node)
}

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
//* *Float value to represent "undefined" in style values.
// 
//* *Structure used to represent a dimension in a style.
// 
struct Value { 
	value f32
	unit YGUnit
}
//* *Constant for a dimension of "auto".
// 
pub const value_auto = C.YGValueAuto

//* *Constant for a dimension which is not defined.
// 
pub const value_undefined = C.YGValueUndefined

//* *Constant for a dimension that is zero-length.
// 
pub const value_zero = C.YGValueZero

//* *Whether a dimension represented as a float is defined.
// 
fn C.YGFloatIsUndefined(value f32) bool

pub fn float_is_undefined(value f32) bool {
	return C.YGFloatIsUndefined(value)
}

// Equality operators for comparison of YGValue in C++
//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
fn C.YGNodeCopyStyle(dst_node YGNodeRef, src_node YGNodeConstRef)

pub fn node_copy_style(dst_node YGNodeRef, src_node YGNodeConstRef) {
	C.YGNodeCopyStyle(dst_node, src_node)
}

fn C.YGNodeStyleSetDirection(node YGNodeRef, direction YGDirection)

pub fn node_style_set_direction(node YGNodeRef, direction YGDirection) {
	C.YGNodeStyleSetDirection(node, direction)
}

fn C.YGNodeStyleGetDirection(node YGNodeConstRef) YGDirection

pub fn node_style_get_direction(node YGNodeConstRef) YGDirection {
	return C.YGNodeStyleGetDirection(node)
}

fn C.YGNodeStyleSetFlexDirection(node YGNodeRef, flex_direction YGFlexDirection)

pub fn node_style_set_flex_direction(node YGNodeRef, flex_direction YGFlexDirection) {
	C.YGNodeStyleSetFlexDirection(node, flex_direction)
}

fn C.YGNodeStyleGetFlexDirection(node YGNodeConstRef) YGFlexDirection

pub fn node_style_get_flex_direction(node YGNodeConstRef) YGFlexDirection {
	return C.YGNodeStyleGetFlexDirection(node)
}

fn C.YGNodeStyleSetJustifyContent(node YGNodeRef, justify_content YGJustify)

pub fn node_style_set_justify_content(node YGNodeRef, justify_content YGJustify) {
	C.YGNodeStyleSetJustifyContent(node, justify_content)
}

fn C.YGNodeStyleGetJustifyContent(node YGNodeConstRef) YGJustify

pub fn node_style_get_justify_content(node YGNodeConstRef) YGJustify {
	return C.YGNodeStyleGetJustifyContent(node)
}

fn C.YGNodeStyleSetAlignContent(node YGNodeRef, align_content YGAlign)

pub fn node_style_set_align_content(node YGNodeRef, align_content YGAlign) {
	C.YGNodeStyleSetAlignContent(node, align_content)
}

fn C.YGNodeStyleGetAlignContent(node YGNodeConstRef) YGAlign

pub fn node_style_get_align_content(node YGNodeConstRef) YGAlign {
	return C.YGNodeStyleGetAlignContent(node)
}

fn C.YGNodeStyleSetAlignItems(node YGNodeRef, align_items YGAlign)

pub fn node_style_set_align_items(node YGNodeRef, align_items YGAlign) {
	C.YGNodeStyleSetAlignItems(node, align_items)
}

fn C.YGNodeStyleGetAlignItems(node YGNodeConstRef) YGAlign

pub fn node_style_get_align_items(node YGNodeConstRef) YGAlign {
	return C.YGNodeStyleGetAlignItems(node)
}

fn C.YGNodeStyleSetAlignSelf(node YGNodeRef, align_self YGAlign)

pub fn node_style_set_align_self(node YGNodeRef, align_self YGAlign) {
	C.YGNodeStyleSetAlignSelf(node, align_self)
}

fn C.YGNodeStyleGetAlignSelf(node YGNodeConstRef) YGAlign

pub fn node_style_get_align_self(node YGNodeConstRef) YGAlign {
	return C.YGNodeStyleGetAlignSelf(node)
}

fn C.YGNodeStyleSetPositionType(node YGNodeRef, position_type YGPositionType)

pub fn node_style_set_position_type(node YGNodeRef, position_type YGPositionType) {
	C.YGNodeStyleSetPositionType(node, position_type)
}

fn C.YGNodeStyleGetPositionType(node YGNodeConstRef) YGPositionType

pub fn node_style_get_position_type(node YGNodeConstRef) YGPositionType {
	return C.YGNodeStyleGetPositionType(node)
}

fn C.YGNodeStyleSetFlexWrap(node YGNodeRef, flex_wrap YGWrap)

pub fn node_style_set_flex_wrap(node YGNodeRef, flex_wrap YGWrap) {
	C.YGNodeStyleSetFlexWrap(node, flex_wrap)
}

fn C.YGNodeStyleGetFlexWrap(node YGNodeConstRef) YGWrap

pub fn node_style_get_flex_wrap(node YGNodeConstRef) YGWrap {
	return C.YGNodeStyleGetFlexWrap(node)
}

fn C.YGNodeStyleSetOverflow(node YGNodeRef, overflow YGOverflow)

pub fn node_style_set_overflow(node YGNodeRef, overflow YGOverflow) {
	C.YGNodeStyleSetOverflow(node, overflow)
}

fn C.YGNodeStyleGetOverflow(node YGNodeConstRef) YGOverflow

pub fn node_style_get_overflow(node YGNodeConstRef) YGOverflow {
	return C.YGNodeStyleGetOverflow(node)
}

fn C.YGNodeStyleSetDisplay(node YGNodeRef, display YGDisplay)

pub fn node_style_set_display(node YGNodeRef, display YGDisplay) {
	C.YGNodeStyleSetDisplay(node, display)
}

fn C.YGNodeStyleGetDisplay(node YGNodeConstRef) YGDisplay

pub fn node_style_get_display(node YGNodeConstRef) YGDisplay {
	return C.YGNodeStyleGetDisplay(node)
}

fn C.YGNodeStyleSetFlex(node YGNodeRef, flex f32)

pub fn node_style_set_flex(node YGNodeRef, flex f32) {
	C.YGNodeStyleSetFlex(node, flex)
}

fn C.YGNodeStyleGetFlex(node YGNodeConstRef) f32

pub fn node_style_get_flex(node YGNodeConstRef) f32 {
	return C.YGNodeStyleGetFlex(node)
}

fn C.YGNodeStyleSetFlexGrow(node YGNodeRef, flex_grow f32)

pub fn node_style_set_flex_grow(node YGNodeRef, flex_grow f32) {
	C.YGNodeStyleSetFlexGrow(node, flex_grow)
}

fn C.YGNodeStyleGetFlexGrow(node YGNodeConstRef) f32

pub fn node_style_get_flex_grow(node YGNodeConstRef) f32 {
	return C.YGNodeStyleGetFlexGrow(node)
}

fn C.YGNodeStyleSetFlexShrink(node YGNodeRef, flex_shrink f32)

pub fn node_style_set_flex_shrink(node YGNodeRef, flex_shrink f32) {
	C.YGNodeStyleSetFlexShrink(node, flex_shrink)
}

fn C.YGNodeStyleGetFlexShrink(node YGNodeConstRef) f32

pub fn node_style_get_flex_shrink(node YGNodeConstRef) f32 {
	return C.YGNodeStyleGetFlexShrink(node)
}

fn C.YGNodeStyleSetFlexBasis(node YGNodeRef, flex_basis f32)

pub fn node_style_set_flex_basis(node YGNodeRef, flex_basis f32) {
	C.YGNodeStyleSetFlexBasis(node, flex_basis)
}

fn C.YGNodeStyleSetFlexBasisPercent(node YGNodeRef, flex_basis f32)

pub fn node_style_set_flex_basis_percent(node YGNodeRef, flex_basis f32) {
	C.YGNodeStyleSetFlexBasisPercent(node, flex_basis)
}

fn C.YGNodeStyleSetFlexBasisAuto(node YGNodeRef)

pub fn node_style_set_flex_basis_auto(node YGNodeRef) {
	C.YGNodeStyleSetFlexBasisAuto(node)
}

fn C.YGNodeStyleSetFlexBasisMaxContent(node YGNodeRef)

pub fn node_style_set_flex_basis_max_content(node YGNodeRef) {
	C.YGNodeStyleSetFlexBasisMaxContent(node)
}

fn C.YGNodeStyleSetFlexBasisFitContent(node YGNodeRef)

pub fn node_style_set_flex_basis_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetFlexBasisFitContent(node)
}

fn C.YGNodeStyleSetFlexBasisStretch(node YGNodeRef)

pub fn node_style_set_flex_basis_stretch(node YGNodeRef) {
	C.YGNodeStyleSetFlexBasisStretch(node)
}

fn C.YGNodeStyleGetFlexBasis(node YGNodeConstRef) YGValue

pub fn node_style_get_flex_basis(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetFlexBasis(node)
}

fn C.YGNodeStyleSetPosition(node YGNodeRef, edge YGEdge, position f32)

pub fn node_style_set_position(node YGNodeRef, edge YGEdge, position f32) {
	C.YGNodeStyleSetPosition(node, edge, position)
}

fn C.YGNodeStyleSetPositionPercent(node YGNodeRef, edge YGEdge, position f32)

pub fn node_style_set_position_percent(node YGNodeRef, edge YGEdge, position f32) {
	C.YGNodeStyleSetPositionPercent(node, edge, position)
}

fn C.YGNodeStyleGetPosition(node YGNodeConstRef, edge YGEdge) YGValue

pub fn node_style_get_position(node YGNodeConstRef, edge YGEdge) YGValue {
	return C.YGNodeStyleGetPosition(node, edge)
}

fn C.YGNodeStyleSetPositionAuto(node YGNodeRef, edge YGEdge)

pub fn node_style_set_position_auto(node YGNodeRef, edge YGEdge) {
	C.YGNodeStyleSetPositionAuto(node, edge)
}

fn C.YGNodeStyleSetMargin(node YGNodeRef, edge YGEdge, margin f32)

pub fn node_style_set_margin(node YGNodeRef, edge YGEdge, margin f32) {
	C.YGNodeStyleSetMargin(node, edge, margin)
}

fn C.YGNodeStyleSetMarginPercent(node YGNodeRef, edge YGEdge, margin f32)

pub fn node_style_set_margin_percent(node YGNodeRef, edge YGEdge, margin f32) {
	C.YGNodeStyleSetMarginPercent(node, edge, margin)
}

fn C.YGNodeStyleSetMarginAuto(node YGNodeRef, edge YGEdge)

pub fn node_style_set_margin_auto(node YGNodeRef, edge YGEdge) {
	C.YGNodeStyleSetMarginAuto(node, edge)
}

fn C.YGNodeStyleGetMargin(node YGNodeConstRef, edge YGEdge) YGValue

pub fn node_style_get_margin(node YGNodeConstRef, edge YGEdge) YGValue {
	return C.YGNodeStyleGetMargin(node, edge)
}

fn C.YGNodeStyleSetPadding(node YGNodeRef, edge YGEdge, padding f32)

pub fn node_style_set_padding(node YGNodeRef, edge YGEdge, padding f32) {
	C.YGNodeStyleSetPadding(node, edge, padding)
}

fn C.YGNodeStyleSetPaddingPercent(node YGNodeRef, edge YGEdge, padding f32)

pub fn node_style_set_padding_percent(node YGNodeRef, edge YGEdge, padding f32) {
	C.YGNodeStyleSetPaddingPercent(node, edge, padding)
}

fn C.YGNodeStyleGetPadding(node YGNodeConstRef, edge YGEdge) YGValue

pub fn node_style_get_padding(node YGNodeConstRef, edge YGEdge) YGValue {
	return C.YGNodeStyleGetPadding(node, edge)
}

fn C.YGNodeStyleSetBorder(node YGNodeRef, edge YGEdge, border f32)

pub fn node_style_set_border(node YGNodeRef, edge YGEdge, border f32) {
	C.YGNodeStyleSetBorder(node, edge, border)
}

fn C.YGNodeStyleGetBorder(node YGNodeConstRef, edge YGEdge) f32

pub fn node_style_get_border(node YGNodeConstRef, edge YGEdge) f32 {
	return C.YGNodeStyleGetBorder(node, edge)
}

fn C.YGNodeStyleSetGap(node YGNodeRef, gutter YGGutter, gap_length f32)

pub fn node_style_set_gap(node YGNodeRef, gutter YGGutter, gap_length f32) {
	C.YGNodeStyleSetGap(node, gutter, gap_length)
}

fn C.YGNodeStyleSetGapPercent(node YGNodeRef, gutter YGGutter, gap_length f32)

pub fn node_style_set_gap_percent(node YGNodeRef, gutter YGGutter, gap_length f32) {
	C.YGNodeStyleSetGapPercent(node, gutter, gap_length)
}

fn C.YGNodeStyleGetGap(node YGNodeConstRef, gutter YGGutter) YGValue

pub fn node_style_get_gap(node YGNodeConstRef, gutter YGGutter) YGValue {
	return C.YGNodeStyleGetGap(node, gutter)
}

fn C.YGNodeStyleSetBoxSizing(node YGNodeRef, box_sizing YGBoxSizing)

pub fn node_style_set_box_sizing(node YGNodeRef, box_sizing YGBoxSizing) {
	C.YGNodeStyleSetBoxSizing(node, box_sizing)
}

fn C.YGNodeStyleGetBoxSizing(node YGNodeConstRef) YGBoxSizing

pub fn node_style_get_box_sizing(node YGNodeConstRef) YGBoxSizing {
	return C.YGNodeStyleGetBoxSizing(node)
}

fn C.YGNodeStyleSetWidth(node YGNodeRef, width f32)

pub fn node_style_set_width(node YGNodeRef, width f32) {
	C.YGNodeStyleSetWidth(node, width)
}

fn C.YGNodeStyleSetWidthPercent(node YGNodeRef, width f32)

pub fn node_style_set_width_percent(node YGNodeRef, width f32) {
	C.YGNodeStyleSetWidthPercent(node, width)
}

fn C.YGNodeStyleSetWidthAuto(node YGNodeRef)

pub fn node_style_set_width_auto(node YGNodeRef) {
	C.YGNodeStyleSetWidthAuto(node)
}

fn C.YGNodeStyleSetWidthMaxContent(node YGNodeRef)

pub fn node_style_set_width_max_content(node YGNodeRef) {
	C.YGNodeStyleSetWidthMaxContent(node)
}

fn C.YGNodeStyleSetWidthFitContent(node YGNodeRef)

pub fn node_style_set_width_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetWidthFitContent(node)
}

fn C.YGNodeStyleSetWidthStretch(node YGNodeRef)

pub fn node_style_set_width_stretch(node YGNodeRef) {
	C.YGNodeStyleSetWidthStretch(node)
}

fn C.YGNodeStyleGetWidth(node YGNodeConstRef) YGValue

pub fn node_style_get_width(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetWidth(node)
}

fn C.YGNodeStyleSetHeight(node YGNodeRef, height f32)

pub fn node_style_set_height(node YGNodeRef, height f32) {
	C.YGNodeStyleSetHeight(node, height)
}

fn C.YGNodeStyleSetHeightPercent(node YGNodeRef, height f32)

pub fn node_style_set_height_percent(node YGNodeRef, height f32) {
	C.YGNodeStyleSetHeightPercent(node, height)
}

fn C.YGNodeStyleSetHeightAuto(node YGNodeRef)

pub fn node_style_set_height_auto(node YGNodeRef) {
	C.YGNodeStyleSetHeightAuto(node)
}

fn C.YGNodeStyleSetHeightMaxContent(node YGNodeRef)

pub fn node_style_set_height_max_content(node YGNodeRef) {
	C.YGNodeStyleSetHeightMaxContent(node)
}

fn C.YGNodeStyleSetHeightFitContent(node YGNodeRef)

pub fn node_style_set_height_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetHeightFitContent(node)
}

fn C.YGNodeStyleSetHeightStretch(node YGNodeRef)

pub fn node_style_set_height_stretch(node YGNodeRef) {
	C.YGNodeStyleSetHeightStretch(node)
}

fn C.YGNodeStyleGetHeight(node YGNodeConstRef) YGValue

pub fn node_style_get_height(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetHeight(node)
}

fn C.YGNodeStyleSetMinWidth(node YGNodeRef, min_width f32)

pub fn node_style_set_min_width(node YGNodeRef, min_width f32) {
	C.YGNodeStyleSetMinWidth(node, min_width)
}

fn C.YGNodeStyleSetMinWidthPercent(node YGNodeRef, min_width f32)

pub fn node_style_set_min_width_percent(node YGNodeRef, min_width f32) {
	C.YGNodeStyleSetMinWidthPercent(node, min_width)
}

fn C.YGNodeStyleSetMinWidthMaxContent(node YGNodeRef)

pub fn node_style_set_min_width_max_content(node YGNodeRef) {
	C.YGNodeStyleSetMinWidthMaxContent(node)
}

fn C.YGNodeStyleSetMinWidthFitContent(node YGNodeRef)

pub fn node_style_set_min_width_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetMinWidthFitContent(node)
}

fn C.YGNodeStyleSetMinWidthStretch(node YGNodeRef)

pub fn node_style_set_min_width_stretch(node YGNodeRef) {
	C.YGNodeStyleSetMinWidthStretch(node)
}

fn C.YGNodeStyleGetMinWidth(node YGNodeConstRef) YGValue

pub fn node_style_get_min_width(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetMinWidth(node)
}

fn C.YGNodeStyleSetMinHeight(node YGNodeRef, min_height f32)

pub fn node_style_set_min_height(node YGNodeRef, min_height f32) {
	C.YGNodeStyleSetMinHeight(node, min_height)
}

fn C.YGNodeStyleSetMinHeightPercent(node YGNodeRef, min_height f32)

pub fn node_style_set_min_height_percent(node YGNodeRef, min_height f32) {
	C.YGNodeStyleSetMinHeightPercent(node, min_height)
}

fn C.YGNodeStyleSetMinHeightMaxContent(node YGNodeRef)

pub fn node_style_set_min_height_max_content(node YGNodeRef) {
	C.YGNodeStyleSetMinHeightMaxContent(node)
}

fn C.YGNodeStyleSetMinHeightFitContent(node YGNodeRef)

pub fn node_style_set_min_height_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetMinHeightFitContent(node)
}

fn C.YGNodeStyleSetMinHeightStretch(node YGNodeRef)

pub fn node_style_set_min_height_stretch(node YGNodeRef) {
	C.YGNodeStyleSetMinHeightStretch(node)
}

fn C.YGNodeStyleGetMinHeight(node YGNodeConstRef) YGValue

pub fn node_style_get_min_height(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetMinHeight(node)
}

fn C.YGNodeStyleSetMaxWidth(node YGNodeRef, max_width f32)

pub fn node_style_set_max_width(node YGNodeRef, max_width f32) {
	C.YGNodeStyleSetMaxWidth(node, max_width)
}

fn C.YGNodeStyleSetMaxWidthPercent(node YGNodeRef, max_width f32)

pub fn node_style_set_max_width_percent(node YGNodeRef, max_width f32) {
	C.YGNodeStyleSetMaxWidthPercent(node, max_width)
}

fn C.YGNodeStyleSetMaxWidthMaxContent(node YGNodeRef)

pub fn node_style_set_max_width_max_content(node YGNodeRef) {
	C.YGNodeStyleSetMaxWidthMaxContent(node)
}

fn C.YGNodeStyleSetMaxWidthFitContent(node YGNodeRef)

pub fn node_style_set_max_width_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetMaxWidthFitContent(node)
}

fn C.YGNodeStyleSetMaxWidthStretch(node YGNodeRef)

pub fn node_style_set_max_width_stretch(node YGNodeRef) {
	C.YGNodeStyleSetMaxWidthStretch(node)
}

fn C.YGNodeStyleGetMaxWidth(node YGNodeConstRef) YGValue

pub fn node_style_get_max_width(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetMaxWidth(node)
}

fn C.YGNodeStyleSetMaxHeight(node YGNodeRef, max_height f32)

pub fn node_style_set_max_height(node YGNodeRef, max_height f32) {
	C.YGNodeStyleSetMaxHeight(node, max_height)
}

fn C.YGNodeStyleSetMaxHeightPercent(node YGNodeRef, max_height f32)

pub fn node_style_set_max_height_percent(node YGNodeRef, max_height f32) {
	C.YGNodeStyleSetMaxHeightPercent(node, max_height)
}

fn C.YGNodeStyleSetMaxHeightMaxContent(node YGNodeRef)

pub fn node_style_set_max_height_max_content(node YGNodeRef) {
	C.YGNodeStyleSetMaxHeightMaxContent(node)
}

fn C.YGNodeStyleSetMaxHeightFitContent(node YGNodeRef)

pub fn node_style_set_max_height_fit_content(node YGNodeRef) {
	C.YGNodeStyleSetMaxHeightFitContent(node)
}

fn C.YGNodeStyleSetMaxHeightStretch(node YGNodeRef)

pub fn node_style_set_max_height_stretch(node YGNodeRef) {
	C.YGNodeStyleSetMaxHeightStretch(node)
}

fn C.YGNodeStyleGetMaxHeight(node YGNodeConstRef) YGValue

pub fn node_style_get_max_height(node YGNodeConstRef) YGValue {
	return C.YGNodeStyleGetMaxHeight(node)
}

fn C.YGNodeStyleSetAspectRatio(node YGNodeRef, aspect_ratio f32)

pub fn node_style_set_aspect_ratio(node YGNodeRef, aspect_ratio f32) {
	C.YGNodeStyleSetAspectRatio(node, aspect_ratio)
}

fn C.YGNodeStyleGetAspectRatio(node YGNodeConstRef) f32

pub fn node_style_get_aspect_ratio(node YGNodeConstRef) f32 {
	return C.YGNodeStyleGetAspectRatio(node)
}

//
// *Copyright (c) Meta Platforms, Inc. and affiliates.
// * *This source code is licensed under the MIT license found in the
// *LICENSE file in the root directory of this source tree.
// 
//* *Rounds a point value to the nearest whole pixel, given a pointScaleFactor
// *describing pixel density.
// *@returns the rounded value in points
// 
fn C.YGRoundValueToPixelGrid(value f64, point_scale_factor f64, force_ceil bool, force_floor bool) f32

pub fn round_value_to_pixel_grid(value f64, point_scale_factor f64, force_ceil bool, force_floor bool) f32 {
	return C.YGRoundValueToPixelGrid(value, point_scale_factor, force_ceil, force_floor)
}

